# Story 1.5: Caddy Reverse Proxy (Epic 1 - Foundation & Core Infrastructure)

## Status
Approved

## Story
**As a** DevOps engineer,
**I want** Caddy 2.10 configured as reverse proxy with automatic SSL,
**so that** all web services have secure HTTPS access with zero configuration overhead.

## Acceptance Criteria
1. Caddy container running with latest stable version
2. Automatic SSL certificate generation working
3. Reverse proxy rules for all services configured
4. HTTP to HTTPS redirection enforced
5. Security headers and CORS policies implemented
6. Caddyfile properly structured for maintainability

## Tasks / Subtasks

- [ ] Create Caddyfile configuration (AC: 3, 4, 5, 6)
  - [ ] Create `config/caddy/Caddyfile` with production-ready reverse proxy configuration
  - [ ] Configure automatic HTTPS with Let's Encrypt for all service domains
  - [ ] Configure HTTP to HTTPS redirection (automatic with Caddy)
  - [ ] Add reverse proxy blocks for all services: n8n, Chatwoot, Evolution API, Lowcoder, Directus, FileFlows, Duplicati
  - [ ] Implement security headers (CSP, X-Frame-Options, X-Content-Type-Options)
  - [ ] Configure CORS policy for API endpoints
  - [ ] Add inline comments documenting each configuration block
  - [ ] Structure Caddyfile for maintainability (group related configs, clear sections)

- [ ] Add Caddy service and volumes to docker-compose.yml (AC: 1, 2, 3, 4, 5)
  - [ ] Define caddy service with exact image version: `caddy:2.10-alpine`
  - [ ] Connect service to borgstack_external network ONLY (Caddy is the gateway)
  - [ ] Expose ports 80 and 443 to host for HTTP/HTTPS access
  - [ ] Mount Caddyfile: `./config/caddy/Caddyfile:/etc/caddy/Caddyfile:ro`
  - [ ] Mount data volume: `borgstack_caddy_data:/data` (for certificates and other data)
  - [ ] Mount config volume: `borgstack_caddy_config:/config` (for auto-saved JSON config)
  - [ ] Configure health check using Caddy's built-in health endpoint
  - [ ] Add restart: unless-stopped policy for reliability
  - [ ] Add inline comments documenting service configuration choices
  - [ ] Add borgstack_caddy_data to volumes section (for certificates)
  - [ ] Add borgstack_caddy_config to volumes section (for auto-saved config)
  - [ ] Follow borgstack_ naming convention per coding standards

- [ ] Update .env.example with Caddy variables (AC: 3)
  - [ ] Add DOMAIN variable for base domain (e.g., example.com.br)
  - [ ] Add subdomain variables for each service (N8N_SUBDOMAIN, CHATWOOT_SUBDOMAIN, etc.)
  - [ ] Add EMAIL variable for Let's Encrypt account notifications
  - [ ] Document DNS configuration requirements in comments
  - [ ] Add comments explaining domain setup and SSL certificate generation

- [ ] Create deployment validation tests (AC: 1, 2, 3, 4, 5, 6)
  - [ ] Create validation test script `tests/deployment/verify-caddy.sh`
  - [ ] Test Caddy container is running and healthy
  - [ ] Verify HTTP to HTTPS redirection works
  - [ ] Verify security headers are present in responses
  - [ ] Test CORS configuration for API endpoints
  - [ ] Verify Caddyfile syntax is valid
  - [ ] Test reverse proxy configuration (using localhost or test domains)
  - [ ] Make script executable (chmod +x)

- [ ] Document reverse proxy configuration and SSL setup (AC: 2, 3, 6)
  - [ ] Add inline comments to docker-compose.yml showing how services will be accessed
  - [ ] Document DNS requirements for SSL certificate generation
  - [ ] Document how to add new services to Caddyfile
  - [ ] Document SSL certificate renewal process (automatic with Caddy)
  - [ ] Document troubleshooting steps for SSL certificate issues

- [ ] Add Caddy validation to CI workflow (AC: 1, 4, 5, 6)
  - [ ] Add Caddyfile syntax validation to .github/workflows/ci.yml
  - [ ] Create test to verify Caddy configuration format
  - [ ] Create test to verify required security headers are configured
  - [ ] Add Caddy validation job to CI pipeline

## Dev Notes

### Previous Story Insights
[Source: Story 1.2 & 1.4 Completion]

Story 1.2 established Docker network configuration with security best practices:
- **Network Isolation:** Caddy must connect to `borgstack_external` network to route traffic to services
- **Single Entry Point:** Only Caddy exposes ports (80, 443) to host - all other services remain internal
- **Service Discovery:** Docker DNS automatically resolves service names - Caddy can route to `http://n8n:5678`, `http://chatwoot:3000`, etc.
- **Multi-Network Pattern:** Application services (n8n, Chatwoot, etc.) connect to BOTH networks (internal for DB, external for Caddy routing)

**Key Takeaway:** Caddy is the ONLY service that should expose ports to the host. All external web access flows through Caddy reverse proxy.

Story 1.4 demonstrated comprehensive configuration file documentation and testing strategy:
- **Configuration as Code:** All configs stored in version control with extensive inline documentation
- **Comprehensive Testing:** Validation scripts covering all acceptance criteria with clear output
- **CI Integration:** Automated tests ensuring continuous validation

**Key Takeaway:** Apply same high standards for Caddy configuration documentation and test coverage.

### Caddy Version and Image
[Source: architecture/tech-stack.md#core-infrastructure]

**Technology Selection:**
- **Image:** `caddy:2.10-alpine`
- **Version:** Caddy 2.10 (Alpine Linux base for minimal footprint)
- **Purpose:** HTTPS termination and routing for all web services
- **Rationale:** Zero-configuration automatic SSL/TLS; simpler than nginx for this use case

**Key Features:**
- Automatic HTTPS via Let's Encrypt integration
- Automatic HTTP to HTTPS redirection
- Automatic certificate renewal
- Simple configuration syntax (Caddyfile)
- Built-in security defaults

### Caddy Configuration Strategy
[Source: architecture/security-and-performance.md, architecture/deployment-architecture.md]

**Reverse Proxy Architecture:**

Caddy serves as the single entry point for all HTTPS traffic, routing requests to internal services based on domain/subdomain:

```
User Request Flow:
1. User accesses https://n8n.example.com.br
2. DNS resolves to server IP
3. Request hits Caddy on port 443
4. Caddy routes to http://n8n:5678 on borgstack_external network
5. n8n service responds through Caddy
6. Caddy returns HTTPS response to user
```

**Services to Configure (Reverse Proxy Blocks):**

| Service | Internal Address | Subdomain Pattern | Story Reference |
|---------|------------------|-------------------|-----------------|
| n8n | http://n8n:5678 | n8n.{$DOMAIN} | Story 2.1 |
| Chatwoot | http://chatwoot:3000 | chatwoot.{$DOMAIN} | Story 3.1 |
| Evolution API | http://evolution:8080 | evolution.{$DOMAIN} | Story 2.2 |
| Lowcoder | http://lowcoder:3000 | lowcoder.{$DOMAIN} | Story 3.2 |
| Directus | http://directus:8055 | directus.{$DOMAIN} | Story 4.1 |
| FileFlows | http://fileflows:5000 | fileflows.{$DOMAIN} | Story 4.2 |
| Duplicati | http://duplicati:8200 | duplicati.{$DOMAIN} | Story 5.2 |

**Caddyfile Structure:**

```Caddyfile
# Global options
{
    email {$EMAIL}
    # Automatic HTTPS
}

# n8n Workflow Automation
n8n.{$DOMAIN} {
    reverse_proxy n8n:5678

    # Security headers
    header {
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
        Referrer-Policy "strict-origin-when-cross-origin"
    }
}

# Chatwoot Customer Service
chatwoot.{$DOMAIN} {
    reverse_proxy chatwoot:3000

    header {
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
    }
}

# Evolution API (WhatsApp Integration)
evolution.{$DOMAIN} {
    reverse_proxy evolution:8080

    # CORS for API access
    @cors_preflight {
        method OPTIONS
    }
    handle @cors_preflight {
        header Access-Control-Allow-Origin "*"
        header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE"
        header Access-Control-Allow-Headers "Content-Type, Authorization"
        respond 204
    }

    header Access-Control-Allow-Origin "*"
}

# Lowcoder Application Builder
lowcoder.{$DOMAIN} {
    reverse_proxy lowcoder:3000

    header {
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
    }
}

# Directus Headless CMS
directus.{$DOMAIN} {
    reverse_proxy directus:8055

    # CORS for API access
    @cors_preflight {
        method OPTIONS
    }
    handle @cors_preflight {
        header Access-Control-Allow-Origin "*"
        header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE"
        header Access-Control-Allow-Headers "Content-Type, Authorization"
        respond 204
    }

    header Access-Control-Allow-Origin "*"
}

# FileFlows Media Processing
fileflows.{$DOMAIN} {
    reverse_proxy fileflows:5000

    header {
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
    }
}

# Duplicati Backup System
duplicati.{$DOMAIN} {
    reverse_proxy duplicati:8200

    header {
        X-Frame-Options "DENY"
        X-Content-Type-Options "nosniff"
    }
}
```

**Security Headers:**
[Source: architecture/security-and-performance.md#frontend-security]

```
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' wss:
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
Referrer-Policy: strict-origin-when-cross-origin
```

Note: Some services (n8n, Lowcoder) require `'unsafe-inline'` and `'unsafe-eval'` for their admin UIs.

**CORS Configuration:**
[Source: architecture/security-and-performance.md#backend-security]

```
Access-Control-Allow-Origin: * (development) or specific domains (production)
Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```

Production deployments should restrict CORS origins to known domains for security.

**Note on Rate Limiting:**
Rate limiting is not required at the reverse proxy level for this deployment. Application-level rate limiting is already provided by individual services (n8n, Chatwoot have built-in rate limiting; Evolution API has built-in rate limiting for WhatsApp API compliance).

### File Locations and Structure
[Source: architecture/unified-project-structure.md]

**Configuration Files to Create:**
```
borgstack/
├── config/
│   └── caddy/
│       └── Caddyfile                 # Reverse proxy + SSL config (AC: 3, 4, 5, 6)
├── tests/
│   └── deployment/
│       └── verify-caddy.sh           # Validation tests (AC: 1, 2, 3, 4, 5, 6)
├── docker-compose.yml                # Caddy service definition (AC: 1, 2)
└── .env.example                      # Environment variable template (AC: 3)
```

**Docker Compose Service Definition:**
[Source: architecture/coding-standards.md#critical-infrastructure-rules]

```yaml
services:
  caddy:
    image: caddy:2.10-alpine  # ✅ Exact version pinning, never use 'latest'
    container_name: borgstack_caddy
    restart: unless-stopped
    networks:
      - borgstack_external  # ✅ External network ONLY (gateway to services)
    ports:
      - "80:80"    # HTTP (auto-redirects to HTTPS)
      - "443:443"  # HTTPS
    volumes:
      - ./config/caddy/Caddyfile:/etc/caddy/Caddyfile:ro
      - borgstack_caddy_data:/data           # Certificates and other data
      - borgstack_caddy_config:/config       # Auto-saved JSON config
    environment:
      DOMAIN: ${DOMAIN}
      EMAIL: ${EMAIL}
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:2019/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

volumes:
  borgstack_caddy_data:
  borgstack_caddy_config:
```

**Health Check Explanation:**
- Caddy exposes an admin API on port 2019 (internal only, not exposed to host)
- The health check uses wget to check if the admin API is responsive
- This verifies Caddy is running and able to process requests

### Docker Compose Coding Standards
[Source: architecture/coding-standards.md#critical-infrastructure-rules]

**CRITICAL RULES for Caddy Configuration:**

1. **Version Pinning:** Always use exact version `caddy:2.10-alpine`, NEVER `latest` tag
2. **Network Configuration:** Caddy connects ONLY to `borgstack_external` network (it routes to services on this network)
3. **Port Exposure:** Caddy is the ONLY service that exposes ports to host (80, 443)
4. **Volume Naming:** Use `borgstack_caddy_data` and `borgstack_caddy_config` prefix per naming convention
5. **Configuration as Code:** Store Caddyfile in version control, not volumes
6. **Health Checks:** Mandatory health check using Caddy admin API endpoint
7. **Service Routing:** Caddy routes to services using Docker DNS (service_name:port)
8. **Environment Variables:** NEVER commit .env file, only .env.example template

### SSL/TLS Configuration
[Source: architecture/tech-stack.md#security, architecture/deployment-architecture.md]

**Automatic HTTPS with Let's Encrypt:**

Caddy automatically obtains and renews SSL certificates from Let's Encrypt for all configured domains. No manual configuration required.

**Requirements:**
1. **DNS A Records:** All subdomains must point to server IP address
   ```
   n8n.example.com.br      A   203.0.113.1
   chatwoot.example.com.br A   203.0.113.1
   evolution.example.com.br A  203.0.113.1
   lowcoder.example.com.br A   203.0.113.1
   directus.example.com.br A   203.0.113.1
   fileflows.example.com.br A  203.0.113.1
   duplicati.example.com.br A  203.0.113.1
   ```

2. **Firewall Rules:** Ports 80 and 443 must be open for ACME challenge and HTTPS access

3. **Email Address:** Valid email for Let's Encrypt account notifications (set in .env as EMAIL variable)

**Certificate Storage:**
- Certificates stored in `borgstack_caddy_data` volume
- Automatic renewal 30 days before expiration
- No manual intervention required

**HTTP to HTTPS Redirection:**
- Automatic with Caddy (no configuration needed)
- All HTTP requests (port 80) automatically redirect to HTTPS (port 443)

### DNS Configuration Requirements
[Source: architecture/deployment-architecture.md#deployment-checklist]

**Pre-Deployment DNS Setup:**

Before deploying Caddy, configure DNS A records for all services:

```bash
# Example for domain: example.com.br
# Replace 203.0.113.1 with actual server IP

n8n.example.com.br      IN  A  203.0.113.1
chatwoot.example.com.br IN  A  203.0.113.1
evolution.example.com.br IN A  203.0.113.1
lowcoder.example.com.br IN  A  203.0.113.1
directus.example.com.br IN  A  203.0.113.1
fileflows.example.com.br IN A  203.0.113.1
duplicati.example.com.br IN A  203.0.113.1
```

**Verification:**
```bash
# Verify DNS propagation before deployment
dig n8n.example.com.br +short
# Should return server IP address
```

**SSL Certificate Generation:**
- Occurs automatically on first request to each subdomain
- Requires port 80 accessible for ACME HTTP-01 challenge
- Can take 30-60 seconds per domain on first deployment
- Caddy retries automatically if initial attempt fails

### Environment Variables
[Source: .env.example pattern from Stories 1.3-1.4]

**.env.example additions:**

```bash
# ════════════════════════════════════════════════════════════════════════════
# Caddy Reverse Proxy Configuration
# ════════════════════════════════════════════════════════════════════════════

# Base domain for all services
# This domain must have DNS A records pointing to your server IP
# Example: example.com.br → Generates subdomains: n8n.example.com.br, chatwoot.example.com.br, etc.
DOMAIN=example.com.br

# Email for Let's Encrypt SSL certificate notifications
# Used for certificate expiration warnings (should never happen due to auto-renewal)
# Replace with administrator email address
EMAIL=admin@example.com.br

# Individual service subdomains (optional customization)
# By default, services use: {service}.{DOMAIN}
# Uncomment and customize if you want different subdomain names
# N8N_SUBDOMAIN=workflows
# CHATWOOT_SUBDOMAIN=support
# EVOLUTION_SUBDOMAIN=whatsapp
# LOWCODER_SUBDOMAIN=apps
# DIRECTUS_SUBDOMAIN=cms
# FILEFLOWS_SUBDOMAIN=media
# DUPLICATI_SUBDOMAIN=backup

# ════════════════════════════════════════════════════════════════════════════
# DNS Configuration Requirements
# ════════════════════════════════════════════════════════════════════════════
# Before deploying, create DNS A records for all subdomains:
#   n8n.example.com.br      A   YOUR_SERVER_IP
#   chatwoot.example.com.br A   YOUR_SERVER_IP
#   evolution.example.com.br A  YOUR_SERVER_IP
#   lowcoder.example.com.br A   YOUR_SERVER_IP
#   directus.example.com.br A   YOUR_SERVER_IP
#   fileflows.example.com.br A  YOUR_SERVER_IP
#   duplicati.example.com.br A  YOUR_SERVER_IP
#
# Verify DNS propagation: dig n8n.example.com.br +short
# SSL certificates generated automatically on first request (30-60 seconds per domain)
```

### Project Structure Alignment
[Source: architecture/unified-project-structure.md]

**No Structural Conflicts:**
- docker-compose.yml already exists from Story 1.1 (add caddy service)
- config/caddy/ directory already exists from Story 1.1 (create Caddyfile)
- tests/deployment/ directory exists from Story 1.2 (add verify-caddy.sh)
- .env.example exists from Story 1.1 (add Caddy variables)
- .github/workflows/ci.yml exists from Story 1.2 (add Caddy validation tests)

**Alignment Notes:**
- Service naming follows lowercase convention: `caddy`
- Volume naming follows `borgstack_` prefix: `borgstack_caddy_data`, `borgstack_caddy_config`
- Configuration as Code approach: Caddyfile in version control
- No new directories needed; work within existing structure

## Testing

### Testing Standards
[Source: architecture/testing-strategy.md]

**Testing Philosophy:**
- **No unit tests**: Caddy is a pre-built Docker image; focus on deployment validation
- **Configuration verification**: Ensure docker-compose.yml and Caddyfile are correct
- **Security validation**: Verify headers, CORS, and HTTPS redirection
- **Integration readiness**: Verify Caddy is ready to route to application services (Stories 2.1-5.2)

### Test Requirements

**1. Docker Compose Configuration Validation:**
```bash
# Verify docker-compose.yml syntax
docker compose config --quiet
# Expected: Exit code 0 (no errors)
```

**2. Caddyfile Syntax Validation:**
```bash
# Validate Caddyfile syntax
docker compose run --rm caddy caddy validate --config /etc/caddy/Caddyfile
# Expected: "Valid configuration"
```

**3. Caddy Container Health Check:**
```bash
# Start Caddy service
docker compose up -d caddy

# Wait for health check to pass
timeout 60s bash -c 'until docker compose ps caddy | grep -q "healthy"; do sleep 2; done'

# Verify health status
docker compose ps caddy
# Expected: STATUS column shows "Up X seconds (healthy)"
```

**4. HTTP to HTTPS Redirection Verification:**
```bash
# Test HTTP redirects to HTTPS (using localhost for testing)
# Note: Full SSL test requires valid DNS and domain
curl -I http://localhost:80 2>&1 | grep -q "301\|302\|Location:"
# Expected: HTTP redirect status code
```

**5. Security Headers Verification:**
```bash
# Verify security headers are configured in Caddyfile
grep -q "X-Frame-Options" config/caddy/Caddyfile
grep -q "X-Content-Type-Options" config/caddy/Caddyfile
# Expected: Exit code 0 (headers found in config)
```

**6. CORS Configuration Verification:**
```bash
# Verify CORS configuration in Caddyfile
grep -q "Access-Control-Allow-Origin" config/caddy/Caddyfile
# Expected: Exit code 0 (CORS configured)
```

**7. Reverse Proxy Configuration Verification:**
```bash
# Verify all services have reverse proxy blocks
grep -q "n8n.{\$DOMAIN}" config/caddy/Caddyfile
grep -q "chatwoot.{\$DOMAIN}" config/caddy/Caddyfile
grep -q "evolution.{\$DOMAIN}" config/caddy/Caddyfile
grep -q "lowcoder.{\$DOMAIN}" config/caddy/Caddyfile
grep -q "directus.{\$DOMAIN}" config/caddy/Caddyfile
grep -q "fileflows.{\$DOMAIN}" config/caddy/Caddyfile
grep -q "duplicati.{\$DOMAIN}" config/caddy/Caddyfile
# Expected: Exit code 0 for all (all services configured)
```

**8. Volume Configuration Verification:**
```bash
# Verify volumes are defined
docker compose config | grep -q "borgstack_caddy_data"
docker compose config | grep -q "borgstack_caddy_config"
# Expected: Exit code 0 for both (volumes defined)
```

**9. Network Configuration Verification:**
```bash
# Verify Caddy is on borgstack_external network
docker compose config | grep -A 10 "caddy:" | grep "borgstack_external"
# Expected: - borgstack_external

# Verify Caddy exposes ports 80 and 443
docker compose config | grep -A 20 "caddy:" | grep -E "80:80|443:443"
# Expected: Both port mappings found
```

**10. Admin API Health Endpoint Test:**
```bash
# Verify Caddy admin API responds (health check endpoint)
docker compose exec caddy wget --no-verbose --tries=1 --spider http://localhost:2019/
# Expected: Exit code 0 (admin API responsive)
```

### Test Script Location
Create automated test script: `tests/deployment/verify-caddy.sh` containing all above tests.

### CI Integration
Add Caddy validation to `.github/workflows/ci.yml`:
```yaml
- name: Validate Caddy Configuration
  run: |
    # Verify docker-compose.yml includes Caddy
    docker compose config | grep "image: caddy:2.10-alpine"

    # Validate Caddyfile syntax (requires caddy image)
    docker compose run --rm caddy caddy validate --config /etc/caddy/Caddyfile

    # Verify security headers configured
    grep -q "X-Frame-Options" config/caddy/Caddyfile
    grep -q "X-Content-Type-Options" config/caddy/Caddyfile

    # Start Caddy for testing
    docker compose up -d caddy
    sleep 15

    # Run validation tests
    bash tests/deployment/verify-caddy.sh
```

### Success Criteria

**All Acceptance Criteria Met:**
- AC1: Caddy container running with latest stable version ✓
- AC2: Automatic SSL certificate generation working ✓
- AC3: Reverse proxy rules for all services configured ✓
- AC4: HTTP to HTTPS redirection enforced ✓
- AC5: Security headers and CORS policies implemented ✓
- AC6: Caddyfile properly structured for maintainability ✓

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-01 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-10-01 | 1.1 | Removed rate limiting references (not supported by standard Caddy image); Merged volume definition tasks into Caddy service task for clarity; Updated architecture doc to clarify rate limiting approach | Sarah (Product Owner) |
