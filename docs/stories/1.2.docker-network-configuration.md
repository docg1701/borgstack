# Story 1.2: Docker Network Configuration (Epic 1 - Foundation & Core Infrastructure)

## Status
Draft

## Story
**As a** system administrator,
**I want** internal Docker networks configured for secure inter-service communication,
**so that** components can communicate safely while maintaining proper isolation.

## Acceptance Criteria
1. Internal network `borgstack_internal` validated in docker-compose.yml
2. External network `borgstack_external` validated for reverse proxy connectivity
3. Network security policies documented between networks
4. Service discovery via DNS names documented (validation deferred to Story 6.1 when services exist)
5. Network isolation configuration documented and verified in docker-compose.yml (service-level testing deferred to Stories 1.3-1.7)
6. Port mapping strategy documented for external access

## Tasks / Subtasks
- [ ] Validate existing network configuration in docker-compose.yml (AC: 1, 2, 5)
  - [ ] Verify `borgstack_internal` network exists with bridge driver and `internal: true` setting
  - [ ] Verify `borgstack_external` network exists with bridge driver for reverse proxy connectivity
  - [ ] Validate network configuration meets security requirements
  - [ ] Verify current docker-compose.yml has no insecure port mappings in network configuration
  - [ ] Verify docker-compose.prod.yml configuration prohibits direct port exposure
- [ ] Document network security policies for future service implementation (AC: 3, 5)
  - [ ] Document which services will connect to `borgstack_internal` (databases, caches, app services)
  - [ ] Document which services will connect to `borgstack_external` (Caddy reverse proxy only)
  - [ ] Document port exposure policy (databases should NOT expose ports to host)
  - [ ] Add inline comments to docker-compose.yml explaining network isolation strategy
  - [ ] Document that databases (PostgreSQL, MongoDB, Redis) will only connect to `borgstack_internal` (to be implemented in Stories 1.3, 1.4, 1.7)
  - [ ] Document that application services will connect to `borgstack_internal` for backend communication (to be implemented in Stories 2.1-4.2)
  - [ ] Document that only Caddy will connect to `borgstack_external` for internet-facing access (to be implemented in Story 1.5)
- [ ] Document service discovery strategy for future services (AC: 4)
  - [ ] Document that Docker DNS automatically resolves service names within networks
  - [ ] Add examples of connection strings using service names (e.g., `postgresql:5432`, `redis:6379`) to Dev Notes or inline comments
  - [ ] Document that DNS resolution testing will be performed in Story 6.1 when services exist
- [ ] Document port mapping strategy for external access (AC: 6)
  - [ ] Document that port mapping will only be via Caddy reverse proxy (ports 80/443)
  - [ ] Document that docker-compose.override.yml will contain dev-only port mappings for debugging
  - [ ] Document that all external access flows through Caddy on ports 80/443 (to be implemented in Story 1.5)
- [ ] Create automated network validation test script (AC: 1, 2, 5)
  - [ ] Create bash test script tests/deployment/verify-network-isolation.sh to verify networks exist with correct configuration
  - [ ] Add test to verify `borgstack_internal` has `internal: true` setting
  - [ ] Add test to verify network driver configuration is correct
  - [ ] Document that service connectivity tests will be added in integration testing (Story 6.1)
  - [ ] Add network validation step to .github/workflows/ci.yml after docker compose config validation

## Dev Notes

### Previous Story Insights
[Source: Story 1.1 Completion]

Story 1.1 established the foundational repository structure including:
- Docker Compose v2 format already established in docker-compose.yml
- Networks `borgstack_internal` and `borgstack_external` fully implemented in docker-compose.yml
- Network `borgstack_internal` configured with `internal: true` for security isolation
- Network `borgstack_external` configured with bridge driver for reverse proxy access
- All configuration files follow Configuration as Code approach (version controlled)

**Key Takeaway:** Networks were fully implemented in Story 1.1. This story validates the implementation, documents network security policies, creates comprehensive testing procedures, and prepares service-to-network assignment guidelines for future service stories (1.3-1.7).

### Network Architecture Requirements
[Source: architecture/tech-stack.md#security]

**Network Isolation Strategy:**
- **borgstack_internal:** Bridge network for service-to-service communication (PostgreSQL, MongoDB, Redis, all application services)
- **borgstack_external:** Bridge network for reverse proxy access (Caddy only)
- Services needing external access connect to BOTH networks (e.g., application services need internal DB access AND external proxy access)
- Databases and caches connect ONLY to borgstack_internal for security

**Service Discovery:**
[Source: architecture/deployment-architecture.md#infrastructure-deployment]
- Docker DNS automatically resolves service names to container IPs within the same network
- Connection strings use service names directly: `postgresql:5432`, `redis:6379`, `mongodb:27017`
- No manual IP configuration needed; Docker handles DNS resolution

### Docker Compose Network Configuration Standards
[Source: architecture/coding-standards.md]

**Critical Network Security Rules:**

1. **Network Naming Convention:**
   ```yaml
   networks:
     borgstack_internal:
       driver: bridge
     borgstack_external:
       driver: bridge
   ```
   - Prefix all networks with `borgstack_` for namespace isolation
   - Use descriptive purpose names: `_internal` for service communication, `_external` for proxy access

2. **Port Exposure Policy:**
   ```yaml
   # ✅ Correct - Database with no host port exposure
   postgresql:
     networks:
       - borgstack_internal
     # NO ports: section in production

   # ❌ Wrong - Database exposed to host (security risk)
   postgresql:
     ports:
       - "5432:5432"
   ```
   [Source: architecture/coding-standards.md#network-isolation]
   - Databases (PostgreSQL, MongoDB, Redis) must NEVER expose ports to host in production
   - Port mappings only allowed in docker-compose.override.yml for local development
   - All external access flows through Caddy reverse proxy on ports 80/443

3. **Multi-Network Service Configuration:**
   ```yaml
   # Services needing both internal DB access and external web access
   n8n:
     networks:
       - borgstack_internal  # For PostgreSQL, Redis connections
       - borgstack_external  # For Caddy reverse proxy

   # Services needing only internal access
   postgresql:
     networks:
       - borgstack_internal  # No external access

   # Services needing only external access
   caddy:
     networks:
       - borgstack_external  # Routes traffic to services
     ports:
       - "80:80"
       - "443:443"
   ```

### File Locations and Modifications
[Source: architecture/source-tree.md]

**Primary File to Modify:**
- `docker-compose.yml` - Define the two networks in the top-level `networks:` section

**Optional Files to Create:**
- `tests/deployment/verify-network-isolation.sh` - Test script to verify network configuration
- Update `.github/workflows/ci.yml` if additional network validation is needed

**Files Already Created in Story 1.1:**
- `docker-compose.override.yml` - Local development overrides (can add dev port mappings here)
- `docker-compose.prod.yml` - Production configuration (ensure minimal port exposure)

### Network Security Considerations
[Source: architecture/tech-stack.md#security]

**Security Best Practices:**
1. **Defense in Depth:** Network isolation is the first layer of defense; even if a service is compromised, attacker cannot directly access databases
2. **Minimal Surface Area:** Only Caddy should accept connections from external networks (ports 80/443)
3. **Internal-Only Services:** PostgreSQL, MongoDB, Redis should be unreachable from host or external networks
4. **Development vs Production:** docker-compose.override.yml can expose ports for debugging, but docker-compose.prod.yml must not

### Testing Approach
[Source: architecture/testing-strategy.md]

**Testing Philosophy:**
- No unit tests required (infrastructure project, not application development)
- Focus on deployment validation and configuration verification
- Ensure network isolation works as designed

**Network Validation Tests:**

1. **Configuration Validation:**
   ```bash
   # Verify docker-compose.yml syntax includes network definitions
   docker compose config --quiet  # Must exit 0

   # Check networks are defined
   docker compose config | grep -A5 "networks:"
   ```

2. **Network Existence Verification:**
   ```bash
   # After deployment, verify networks exist
   docker network ls | grep borgstack_internal
   docker network ls | grep borgstack_external
   ```

3. **Network Configuration Test:**
   ```bash
   # Verify borgstack_internal has internal flag set
   docker network inspect borgstack_internal --format '{{.Internal}}'
   # Expected output: true

   # Verify borgstack_external does not have internal flag
   docker network inspect borgstack_external --format '{{.Internal}}'
   # Expected output: false
   ```

   Note: Service discovery tests (DNS resolution) will be performed in Story 6.1 Integration Testing when services are deployed.

4. **Network Configuration Validation:**
   ```bash
   # Verify network configuration in docker-compose.yml
   docker compose config | grep -A 5 "networks:"
   # Verify borgstack_internal and borgstack_external are defined

   # Verify internal network has correct settings
   docker compose config | grep -A 3 "borgstack_internal:" | grep "internal: true"
   ```

   Note: Network isolation tests (verifying databases are not accessible from host) will be performed in Stories 1.3-1.7 when database services are deployed.

5. **Port Exposure Verification:**
   ```bash
   # Verify no services currently expose ports (services don't exist yet)
   docker compose config | grep -A 20 "services:" | grep "ports:" || echo "PASS: No port exposure in base configuration"

   # This test will be enhanced in Story 1.5 (Caddy) to verify only Caddy exposes ports 80/443
   ```

**Test Script Location:**
- Create `tests/deployment/verify-network-isolation.sh` with the above tests
- Update `.github/workflows/ci.yml` to run network validation after config validation

### Project Structure Alignment

**No Structural Conflicts:**
- docker-compose.yml already exists from Story 1.1
- This story adds/modifies the `networks:` section in that file
- Test scripts follow existing structure: `tests/deployment/` directory already exists
- CI workflow already validates Docker Compose configuration

**Alignment Notes:**
- Network naming follows established `borgstack_*` convention from Story 1.1
- Configuration as Code approach maintained (networks defined in version-controlled docker-compose.yml)
- No new directories needed; work within existing structure

## Testing

### Testing Standards
[Source: architecture/testing-strategy.md]

**Testing Focus:**
- Deployment validation: Verify networks are created correctly
- Configuration verification: Ensure docker-compose.yml network definitions are valid
- Security validation: Confirm network isolation prevents unauthorized access

**Test Requirements:**
1. Docker Compose configuration syntax validation (already in CI from Story 1.1)
2. Network existence verification (networks defined in docker-compose.yml)
3. Network configuration validation (internal flag, driver settings)
4. Network security documentation completeness
5. Port exposure policy verification (no unauthorized ports in base config)

Note: Service discovery tests and network isolation tests will be performed in later stories when services are deployed (Stories 1.3-1.7 for databases, Story 6.1 for integration testing).

**Test Execution Commands:**
```bash
# Configuration validation (CI)
docker compose config --quiet

# Network verification
docker compose config | grep -A 5 "networks:"
docker network ls | grep borgstack  # After docker compose up

# Network configuration validation
docker network inspect borgstack_internal --format '{{.Internal}}'  # Should be: true
docker network inspect borgstack_external --format '{{.Internal}}'  # Should be: false

# Port exposure verification
docker compose config | grep -A 20 "services:" | grep "ports:" || echo "PASS: No port exposure"
```

**Success Criteria:**
- docker-compose.yml passes validation with network definitions
- Both `borgstack_internal` and `borgstack_external` networks are properly configured
- `borgstack_internal` has `internal: true` setting for security isolation
- `borgstack_external` is configured for reverse proxy access
- Network security policies are comprehensively documented
- No unauthorized port exposure in base configuration
- Service-to-network assignment strategy documented for future stories

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-09-30 | 1.1 | Story validation corrections: Updated to reflect networks already implemented in Story 1.1; Changed AC from "implemented" to "documented/validated"; Reframed tasks as documentation/validation (services don't exist yet); Updated tests to focus on network config validation only; Added forward references to future stories for service implementation | Sarah (Product Owner) |
| 2025-09-30 | 1.2 | PO validation corrections: Clarified AC #4 and #5 to explicitly defer service-level validation to future stories (6.1 for DNS, 1.3-1.7 for isolation); Restructured tasks to clearly separate "validate now" (network config) from "document for future" (service assignments); Added explicit bash test script reference; Note on Epic AC #3 discrepancy: Epic says "implemented" but story correctly uses "documented" since networks were created in 1.1 | Sarah (Product Owner) |
| 2025-09-30 | 1.3 | Epic-Story alignment correction: Updated Epic 1 Story 1.2 ACs in epic-details.md to match story scope (validated/documented language); Removed semantic mismatch between Epic and Story; Epic ACs now correctly reflect that networks were created in Story 1.1 and this story validates/documents them | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used
<!-- To be filled by Dev Agent -->

### Debug Log References
<!-- To be filled by Dev Agent -->

### Completion Notes List
<!-- To be filled by Dev Agent -->

### File List
<!-- To be filled by Dev Agent -->

## QA Results
<!-- To be filled by QA Agent -->
