# BorgStack - Docker Compose Configuration
# Docker Compose v2 Format
#
# This is the main orchestration file for BorgStack.
# Services will be added incrementally as the project develops.
#
# Architecture: All services share borgstack_internal network for inter-service communication
# External access is routed through Caddy reverse proxy on borgstack_external network
#
# IMPORTANT: Always pin exact image versions. Never use 'latest' tag.

# Services will be defined here as we build out the stack
services:
  # ==========================================================================
  # PostgreSQL Database (Shared)
  # ==========================================================================
  # Primary relational database for n8n, Chatwoot, Directus, and Evolution API
  # Image: pgvector/pgvector:pg18 (PostgreSQL 18.0 with pgvector extension)
  # pgvector extension enables vector similarity search for AI/LLM features
  #
  # Database Organization:
  #   - n8n_db: n8n workflow automation (pgvector enabled for AI nodes)
  #   - chatwoot_db: Chatwoot customer service platform
  #   - directus_db: Directus headless CMS (pgvector enabled for AI features)
  #   - evolution_db: Evolution API WhatsApp gateway
  #
  # Connection Strings (for use in future service stories):
  #   n8n:         postgres://n8n_user:${N8N_DB_PASSWORD}@postgresql:5432/n8n_db
  #   Chatwoot:    postgres://chatwoot_user:${CHATWOOT_DB_PASSWORD}@postgresql:5432/chatwoot_db
  #   Directus:    postgres://directus_user:${DIRECTUS_DB_PASSWORD}@postgresql:5432/directus_db
  #   Evolution:   postgres://evolution_user:${EVOLUTION_DB_PASSWORD}@postgresql:5432/evolution_db
  #
  # Security:
  #   - NO port exposure to host (internal network access only per Story 1.2)
  #   - Each service has dedicated database and user (principle of least privilege)
  #   - Services connect using Docker DNS: postgresql:5432
  #
  # Performance:
  #   - Tuned for 36GB RAM server
  #   - shared_buffers=8GB, effective_cache_size=24GB
  #   - max_connections=200 for connection pooling
  #   - SSD-optimized settings (random_page_cost=1.1)
  #
  # Backup Strategy:
  #   - Automated: Duplicati (Story 5.2) backs up borgstack_postgresql_data volume
  #   - Manual backup: docker compose exec postgresql pg_dumpall -U postgres > backup.sql
  #   - Manual restore: docker compose exec -T postgresql psql -U postgres < backup.sql
  # ==========================================================================
  postgresql:
    image: pgvector/pgvector:pg18
    container_name: borgstack_postgresql
    restart: unless-stopped
    networks:
      - borgstack_internal
    # ⚠️  NO ports section in production - databases must not expose ports to host
    # ℹ️  For local development, add port mapping in docker-compose.override.yml
    volumes:
      - borgstack_postgresql_data:/var/lib/postgresql/data
      - ./config/postgresql/init-databases.sql:/docker-entrypoint-initdb.d/init-databases.sql:ro
      - ./config/postgresql/postgresql.conf:/etc/postgresql/postgresql.conf:ro
    environment:
      # PostgreSQL superuser password (for administration only)
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      # Service-specific database passwords (used in init-databases.sql)
      N8N_DB_PASSWORD: ${N8N_DB_PASSWORD}
      CHATWOOT_DB_PASSWORD: ${CHATWOOT_DB_PASSWORD}
      DIRECTUS_DB_PASSWORD: ${DIRECTUS_DB_PASSWORD}
      EVOLUTION_DB_PASSWORD: ${EVOLUTION_DB_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    # Load custom postgresql.conf with performance tuning
    command: postgres -c config_file=/etc/postgresql/postgresql.conf

#   redis:
#     image: redis:8.2-alpine
#     networks:
#       - borgstack_internal
#     volumes:
#       - borgstack_redis_data:/data
#
#   (Additional services: n8n, chatwoot, evolution-api, lowcoder, directus, fileflows, seaweedfs, duplicati, caddy)

networks:
  borgstack_internal:
    driver: bridge
    internal: true
    # ════════════════════════════════════════════════════════════════════════════
    # INTERNAL NETWORK - Service-to-Service Communication
    # ════════════════════════════════════════════════════════════════════════════
    # Purpose: Secure backend communication between application services and databases
    # Security: internal: true prevents external host access - defense in depth
    #
    # Services connecting to this network (to be implemented in future stories):
    #   - PostgreSQL (Story 1.3)       - Database for n8n, Chatwoot, Directus, Evolution API
    #   - MongoDB (Story 1.4)          - Database for Lowcoder
    #   - Redis (Story 1.7)            - Cache/queue for all services
    #   - n8n (Story 2.1)              - Workflow automation (internal + external)
    #   - Chatwoot (Story 3.1)         - Customer service (internal + external)
    #   - Evolution API (Story 2.2)    - WhatsApp API (internal + external)
    #   - Lowcoder (Story 3.3)         - App builder (internal + external)
    #   - Directus (Story 4.1)         - Headless CMS (internal + external)
    #   - FileFlows (Story 4.2)        - Media processing (internal + external)
    #   - SeaweedFS (Story 1.6)        - Object storage (internal + external)
    #   - Duplicati (Story 1.8)        - Backup system (internal only)
    #
    # Service Discovery (Docker DNS - automatic):
    #   Connection strings use service names directly, no manual IP configuration:
    #     - PostgreSQL: postgresql:5432
    #     - MongoDB:    mongodb:27017
    #     - Redis:      redis:6379
    #   Example: DB_HOST=postgresql DB_PORT=5432 (DNS resolves automatically)
    #
    # Port Exposure Policy:
    #   ✅ Databases/caches: NO ports section in production (internal access only)
    #   ❌ Never expose database ports to host: prevents unauthorized direct access
    #   ℹ️  Dev port mappings allowed in docker-compose.override.yml for debugging

  borgstack_external:
    driver: bridge
    # ════════════════════════════════════════════════════════════════════════════
    # EXTERNAL NETWORK - Reverse Proxy Access
    # ════════════════════════════════════════════════════════════════════════════
    # Purpose: Internet-facing traffic routing through Caddy reverse proxy
    # Security: Only Caddy exposes ports 80/443 to host - single entry point
    #
    # Services connecting to this network:
    #   - Caddy (Story 1.5)            - HTTPS termination, routing (ONLY service exposing ports to host)
    #   - Application services         - Connect to BOTH networks for DB access + external routing
    #
    # Multi-Network Pattern (services needing both internal DB access and external web access):
    #   services:
    #     n8n:
    #       networks:
    #         - borgstack_internal    # For PostgreSQL, Redis connections
    #         - borgstack_external    # For Caddy reverse proxy routing
    #
    # Port Mapping Strategy:
    #   ✅ Only Caddy exposes ports 80/443 to host (implemented in Story 1.5)
    #   ✅ All external access flows through Caddy reverse proxy
    #   ℹ️  Application services accessed via: https://service.yourdomain.com (Caddy routes internally)
    #   ℹ️  Dev environment: docker-compose.override.yml may expose additional ports for debugging

# Volumes will be added as services are implemented
# All volumes must use the borgstack_ prefix
volumes:
  borgstack_postgresql_data:
    # PostgreSQL data directory
    # Contains all databases: n8n_db, chatwoot_db, directus_db, evolution_db
    # Backed up by Duplicati (Story 5.2)
    # Manual backup: docker compose exec postgresql pg_dumpall -U postgres > backup.sql

# Additional volumes (to be added in future stories):
#   borgstack_mongodb_data:
#   borgstack_redis_data:
#   borgstack_n8n_data:
#   borgstack_chatwoot_data:
#   borgstack_evolution_data:
#   borgstack_lowcoder_data:
#   borgstack_directus_data:
#   borgstack_fileflows_data:
#   borgstack_seaweedfs_data:
#   borgstack_duplicati_data:
#   borgstack_caddy_data:
#   borgstack_caddy_config:
