# ============================================================================
# BorgStack - PostgreSQL Performance Configuration
# ============================================================================
#
# Target Environment: 36GB RAM dedicated server
# PostgreSQL Version: 18.0
# Workload Type: Mixed OLTP (n8n, Chatwoot, Directus, Evolution API)
#
# Tuning Philosophy:
#   - Optimized for 4 concurrent application services
#   - Balanced for read/write operations with connection pooling
#   - SSD-optimized random page cost
#   - Conservative WAL settings for data reliability
#
# Configuration generated using PostgreSQL best practices:
#   - shared_buffers: ~25% of RAM (PostgreSQL recommendation)
#   - effective_cache_size: ~66% of RAM (OS file cache estimate)
#   - work_mem: Calculated for max_connections to avoid OOM
# ============================================================================

# ----------------------------------------------------------------------------
# MEMORY CONFIGURATION
# ----------------------------------------------------------------------------

# shared_buffers: Amount of memory dedicated to PostgreSQL for caching data
# Rule: 25% of total RAM for dedicated database servers
# Calculation: 36GB * 0.25 = 9GB (using 8GB for safety margin)
# Impact: Higher values reduce disk I/O by keeping more data in memory
shared_buffers = 8GB

# effective_cache_size: Estimate of memory available for disk caching by OS
# Rule: ~66% of total RAM (includes PostgreSQL buffers + OS file cache)
# Calculation: 36GB * 0.66 = 24GB
# Impact: Influences query planner decisions for index vs sequential scans
effective_cache_size = 24GB

# work_mem: Memory for sorting and hash operations PER operation PER connection
# Rule: (Total RAM - shared_buffers) / (max_connections * 2-3)
# Calculation: (36GB - 8GB) / (200 * 3) ≈ 20MB
# Impact: Higher values improve sort/hash performance but risk OOM if too high
# Note: Each complex query may use multiple work_mem allocations
work_mem = 20MB

# maintenance_work_mem: Memory for maintenance operations (VACUUM, CREATE INDEX)
# Rule: Up to 2GB for large databases (higher than work_mem is safe)
# Impact: Speeds up VACUUM, CREATE INDEX, ALTER TABLE operations
maintenance_work_mem = 2GB

# ----------------------------------------------------------------------------
# CONNECTION CONFIGURATION
# ----------------------------------------------------------------------------

# listen_addresses: IP addresses on which the server listens for connections
# Rule: '*' = all available IP interfaces (required for Docker networking)
# Impact: Allows application containers to connect to PostgreSQL
# Security: pg_hba.conf controls which clients can actually connect
listen_addresses = '*'

# password_encryption: Method used for password encryption
# Rule: scram-sha-256 is the most secure method (default in PostgreSQL 14+)
# Impact: Passwords created with CREATE USER will use this encryption
# Note: Must match authentication method in pg_hba.conf
password_encryption = scram-sha-256

# max_connections: Maximum number of concurrent database connections
# Calculation: 4 services * ~50 connections each = 200 total
# Service allocation estimate:
#   - n8n: 50 connections (workflow executions)
#   - Chatwoot: 50 connections (web workers + sidekiq)
#   - Directus: 50 connections (API requests)
#   - Evolution API: 50 connections (WhatsApp message processing)
# Note: Services should implement connection pooling for efficiency
max_connections = 200

# ----------------------------------------------------------------------------
# WRITE-AHEAD LOG (WAL) CONFIGURATION
# ----------------------------------------------------------------------------

# wal_buffers: Amount of shared memory for WAL data before writing to disk
# Rule: Auto-calculated as 1/32 of shared_buffers (16MB recommended)
# Impact: Reduces disk writes for WAL activity
wal_buffers = 16MB

# min_wal_size: Minimum size to shrink WAL disk usage to
# Rule: Larger values reduce checkpoint frequency (better performance)
# Impact: PostgreSQL won't recycle WAL files below this size
min_wal_size = 1GB

# max_wal_size: Maximum size WAL can grow before forcing a checkpoint
# Rule: 2-4x min_wal_size for write-heavy workloads
# Impact: Larger values = fewer checkpoints = better write performance
# Trade-off: Larger values increase crash recovery time
max_wal_size = 4GB

# checkpoint_completion_target: Fraction of checkpoint interval to spread writes
# Rule: 0.9 = spread checkpoint writes over 90% of interval
# Impact: Reduces I/O spikes by smoothing out checkpoint writes
checkpoint_completion_target = 0.9

# ----------------------------------------------------------------------------
# QUERY PLANNER CONFIGURATION
# ----------------------------------------------------------------------------

# random_page_cost: Planner's estimate of random page access cost vs sequential
# Rule: 1.1 for SSD (default 4.0 is for spinning disks)
# Impact: Encourages planner to use indexes on SSD storage
# Note: Lower value makes index scans more attractive to query planner
random_page_cost = 1.1

# effective_io_concurrency: Number of concurrent disk I/O operations
# Rule: 200 for SSD (default 1 is for single spinning disk)
# Impact: Enables parallel I/O operations for bitmap heap scans
effective_io_concurrency = 200

# default_statistics_target: Amount of statistics collected for query planning
# Rule: 100 is default (higher = better plans but slower ANALYZE)
# Impact: More accurate query plans for complex queries
default_statistics_target = 100

# ----------------------------------------------------------------------------
# LOGGING CONFIGURATION (Optional - Customize per environment)
# ----------------------------------------------------------------------------

# Uncomment these for production logging (disabled by default for performance)
# log_destination = 'stderr'
# logging_collector = on
# log_directory = 'log'
# log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
# log_rotation_age = 1d
# log_rotation_size = 100MB
# log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
# log_checkpoints = on
# log_connections = on
# log_disconnections = on
# log_duration = off
# log_lock_waits = on

# ----------------------------------------------------------------------------
# LOCALE AND FORMATTING
# ----------------------------------------------------------------------------

# Use default locale settings from container environment
# These are typically set via environment variables (LC_ALL, LANG)

# ----------------------------------------------------------------------------
# CONFIGURATION COMPLETE
# ----------------------------------------------------------------------------
#
# Summary:
#   ✅ Memory optimized for 36GB RAM server
#   ✅ Connection pooling supported (max_connections=200)
#   ✅ WAL configured for reliability and performance
#   ✅ SSD-optimized query planner settings
#
# Performance Verification:
#   Run these commands to verify settings are loaded:
#   - SELECT name, setting FROM pg_settings WHERE name = 'shared_buffers';
#   - SELECT name, setting FROM pg_settings WHERE name = 'max_connections';
#   - SELECT name, setting FROM pg_settings WHERE name = 'effective_cache_size';
#
# Monitoring:
#   Monitor these metrics in production:
#   - Connection usage: SELECT count(*) FROM pg_stat_activity;
#   - Cache hit ratio: pg_stat_database (should be >99%)
#   - Checkpoint frequency: pg_stat_bgwriter
# ============================================================================
